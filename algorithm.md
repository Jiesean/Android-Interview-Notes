# 算法

## 排序算法

### 选择排序

#### 实现思路

1. 第一次遍历所有元素，从中选择最小的元素，放置在第一个位置
2. 第二次遍历第一个元素后的所有元素，从中选择最小元素，放置在第二个位置
3. 重复上述动作，直到前n-1的最小元素都选出来

#### 复杂度分析

O(n) = n + (n -1) + (n -2) +........ +1

​         =  (n + 1)* n/2

最大n^2 ,所以选择排序是O(n^2)级别的排序算法

#### 代码实现

[算法示例 testSelectSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 插入排序

#### 实现思路

插入排序的实现思想就是跟扑克牌插排是一样的，依次遍历所有的数，然后将他们插入到前面合适的位置

#### 复杂度分析

O(n) = 1 + 2 + ...... + n -1

​         = n * n/2

最大n^2,所以插入排序也是一个O(n^2)级别的排序算法

插入排序有序的情况下可以直接结束内层循环，在近乎有序的情况下，插入排序接近于O(n)，因此在某些接近有序的数组排序中可以选择插入排序

#### 性能优化

每次交换都需要进行三次copy ,可以优化为进行比较，然后移动其他元素，最终将待插入元素放到最终位置，这样可以实现只需要每次减少为一次copy

#### 代码实现

[插入排序 testInsertionSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 冒泡排序

#### 实现思路

从第1个元素开始遍历一遍元素，将最大的元素放到最后

重复n此，依次将最大元素冒出到后面

#### 复杂度分析

O(n) = n-1 + n-2 + ...... + 1

​         =   n * n/2

最大n^2,所以冒泡排序也是一个O(n^2)级别的排序算法

经过优化后，在数组完全有序的情况下可以收敛成O(1)的算法

#### 性能优化

在某次冒泡的过程中，如果一次交换也没有，那么说明该数据已经是有序的，那么可以不进行下一次冒泡

#### 代码实现

[冒泡排序 testBubbleSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 希尔排序

#### 实现思路

在已实现的插入排序中，如果在基本有序的情况下可以实现在很快的时间内完成排序，但是如果数据本身是接近倒叙的，那么插入排序每个元素移动到前面需要华为很多额外的移动，
为了优化该场景，可以通过希尔排序来实现。

希尔排序通过将一定数组下标位置等差将想个一定距离的数据分成一组数据，分别对每一组数据进行插入排序的过程，实现每组数据为有序，这样一个元素移动到前面的代价就会小很多，
通过缩小等差，直到等差为1，完成此轮插入排序，即可实现整个数组的有序化

所以希尔排序的本质是分组插入排序

#### 复杂度分析

O(n) = n^1.5

在最好的情况下，希尔排序是可以达到n^1.5，在某些情况下也会劣化成n^2，希尔排序是第一批突破n^2的排序算法

#### 性能优化

希尔排序的优化因为近乎插入排序，因此在做每次插入的过程中可以使用插入排序的优化，先移动再进行copy,这样可以减少两倍的copy过程

#### 代码实现

[希尔排序 testShellSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 归并排序

#### 实现思路

采用了分治思想，其遵循以下步骤进行：

1. 将n个元素分成含n/2个元素的子序列
2. 用合并排序法对两个子序列递归的排序
3. 合并两个已经排序好的子序列得到排序结果

代码实现上可以两种方式：

1. 递归实现
2. 迭代实现

#### 复杂度分析

归并排序的过程会将n个元素分为logn层，每层进行归并的时候的消耗是n,所以是

O(n) = nlogn

#### 性能优化

在两个子序列进行归并的时候，可以判断左边子序列的尾部元素a和右边子序列头部元素b的大小，

如果a<=b ,那么既可以跳过本次归并，因为两个直接子序列已经是有序

#### 代码实现

[归并排序 testMergelSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

#### 延伸问题

求解一个序列中的逆序对数量？

思路：借助每次归并的过程，其中每次比较两个子序列元素的时，如果右边子序列中的元素小时，那么该元素和左边子序列所有剩余元素均构成了逆序对，剩余元素个数即可加到逆序对总数上，当完成所有的归并过程后，整个序列中的逆序对个数也就求解出来了

### 快速排序

#### 实现思路

使用一个标定元素，将整个序列分成左右两个序列，满足左边的序列小于等于标定元素，右边的子序列大于标定元素，继续对左右子序列重复上述过程，直至所有元素有效

#### 复杂度分析

O(n) = nlogn

#### 性能优化

快速排序的过程所能做的优化重要是partition的过程，其中可以做的优化主要如下：

1. 如果一直选用第一个元素作为标定元素来进行partition过程，在序列基本有序的情况下，每次partition之后的结果是左边没有元素，右边是剩余所有元素，这种情况下插入排序会劣化到O(n^2)，这种情况下我们可以选择随机元素作为标定元素来解决该问题
2. 如果每趟partition都将等于标定元素的放置到一边，那么在序列有较多重复元素的情况下，也会导致每趟partition将序列分为左右很不均衡的子序列，这样也会导致算法退化成O(n^2)，为了解决该问题，可以利用2路快速排序，也可以通过3路快速排序进一步优化该过程，详情参考代码实现

#### 延伸问题

求解一个数组中的第n大(小)元素？

思路：参考快速排序的过程，每次做完一趟partition，标定元素会被放置在最终有序数列的正确位置，因此每次partition完成，看标定元素所属位置是否等于n,等于则找到该元素；如果小于n,只需要再次对右边序列进行partition知道找到该元素；否则对左边序列进行partition.



### 分治思想

分而治之，将原问题分割为具有同等结构的子问题，之后将子问题逐一解决后，原问题也得到了解决

注意体会经典算法的思路，注意体会前人为了解决什么问题而想出的这个算法



## 图论

### 图的定义

#### 有向性

有向图

无向图

#### 路径加权

有权图

无权图

#### 图的连通性

#### 简单图

忽略平行边、自环边

#### 实现方式

邻接矩阵 ---- 稠密图

邻接表 ----- 稀疏图