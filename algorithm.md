# 算法

## 排序算法

### 选择排序

#### 实现思路

1. 第一次遍历所有元素，从中选择最小的元素，放置在第一个位置
2. 第二次遍历第一个元素后的所有元素，从中选择最小元素，放置在第二个位置
3. 重复上述动作，直到前n-1的最小元素都选出来

#### 复杂度分析

O(n) = n + (n -1) + (n -2) +........ +1

​         =  (n + 1)* n/2

最大n^2 ,所以选择排序是O(n^2)级别的排序算法

#### 代码实现

[算法示例 testSelectSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 插入排序

#### 实现思路

插入排序的实现思想就是跟扑克牌插排是一样的，依次遍历所有的数，然后将他们插入到前面合适的位置

#### 复杂度分析

O(n) = 1 + 2 + ...... + n -1

​         = n * n/2

最大n^2,所以插入排序也是一个O(n^2)级别的排序算法

插入排序有序的情况下可以直接结束内层循环，在近乎有序的情况下，插入排序接近于O(n)，因此在某些接近有序的数组排序中可以选择插入排序

#### 性能优化

每次交换都需要进行三次copy ,可以优化为进行比较，然后移动其他元素，最终将待插入元素放到最终位置，这样可以实现只需要每次减少为一次copy

#### 代码实现

[插入排序 testInsertionSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)

### 冒泡排序

#### 实现思路

从第1个元素开始遍历一遍元素，将最大的元素放到最后

重复n此，依次将最大元素冒出到后面

#### 复杂度分析

O(n) = n-1 + n-2 + ...... + 1

​         =   n * n/2

最大n^2,所以冒泡排序也是一个O(n^2)级别的排序算法

经过优化后，在数组完全有序的情况下可以收敛成O(1)的算法

#### 性能优化

在某次冒泡的过程中，如果一次交换也没有，那么说明该数据已经是有序的，那么可以不进行下一次冒泡

#### 代码实现

[冒泡排序 testBubbleSort](https://github.com/Jiesean/Android-Interview-Notes/tree/master/demo/AlgorithmTrain)